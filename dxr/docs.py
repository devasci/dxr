import json
import os

'''
This module implements documentation coverage for an entire codebase.

Documentation is generated by the indexers and added into the master database.
As there is no need to search documentation, an auxiliary file is used to store
the documentation data.

Four types of documentable entities are recognized by DXR. These correspond to
files, namespaces, aggregates, and leaves.

This module expects to be doing the documentation comment to HTML conversion
itself, using a syntax rather similar to that of Javadoc and Doxygen.
'''

class DocumentableEntity(object):
  def __init__(self, jsondata, docid, lazyloader):
    self.docid = docid
    self._lazyloader = lazyloader
    for key, value in jsondata.iteritems():
      setattr(self, key, value)
    self._resolvedMembers = False

  def getMemberGroups(self):
    if not self._resolvedMembers:
      for group in self.members:
        group['members'] = [self._lazyloader.getEntity(n)
                            for n in group['members']]
      self.members = [NamedList(x['listname'], x['members'])
                      for x in self.members]
      self._resolvedMembers = True
    return self.members

  def getLocationString(self, wwwroot, tree):
    locs = self.location.split(":")
    filename = os.path.relpath(locs[0],"/src/OpenSkyscraper") # XXX
    line = locs[1]
    return ("Defined at <tt><a href=\"%(wwwroot)s/%(tree)s/" +
        "%(filename)s#l%(line)s\">%(location)s</a></tt>") % {
        "filename": filename,
        "wwwroot": wwwroot,
        "tree": tree,
        "line": line,
        "location": self.location}

  def getBriefDocumentation(self):
    return self.briefdoc

  def getFullDocumentation(self):
    return self.fulldoc

class FileEntity(DocumentableEntity):
  pass

class NamespaceEntity(DocumentableEntity):
  def __init__(self, jsondata, docid, lazyloader):
    DocumentableEntity.__init__(self, jsondata, docid, lazyloader)
    self.qualifiedName = jsondata['qualname']

  def getTitle(self):
    return self.qualifiedName

  def getHeader(self):
    return "namespace " + self.qualifiedName

  def getProlog(self):
    return self.getHeader()

class AggregateEntity(DocumentableEntity):
  def __init__(self, jsondata, docid, lazyloader):
    DocumentableEntity.__init__(self, jsondata, docid, lazyloader)
    self.qualifiedName = jsondata['qualname']

  def getTitle(self):
    return self.qualifiedName

  def getHeader(self):
    return self.kind + " " + self.qualifiedName

  def getProlog(self):
    return self.prolog

  def getPrename(self):
    return self.prename

  def getPostname(self):
    return ""

  def getSummaryLink(self):
    return str(self.docid)

class LeafEntity(DocumentableEntity):
  def __init__(self, jsondata, docid, lazyloader):
    DocumentableEntity.__init__(self, jsondata, docid, lazyloader)

  def getPrename(self):
    return self.prename
  def getPostname(self):
    return self.postname
  def getSummaryLink(self):
    return "" # XXX


class NamedList(object):
  def __init__(self, name, members):
    self.name = name
    self.members = members

  def getName(self):
    return self.name

  def getMembers(self):
    return self.members

allEntities = list()
qualmap = dict()

def processDocumentation(doc):
  lines = doc.split('\n')
  outbuffer = ''
  inPara = False
  for line in lines:
    trimmed = line.strip()
    if inPara and trimmed == "":
      outbuffer += "</p>"
      inPara = False
      continue
    elif not inPara and trimmed != "":
      outbuffer += "<p>"
      inPara = True
    if trimmed != "":
      outbuffer += trimmed + " "
  if inPara:
    outbuffer += "</p>"
  return outbuffer

def getNodeNumber(data):
  num = len(allEntities)
  if 'qualname' in data:
    qname = data['qualname']
    if qname in qualmap:
      return qualmap[qname]
    qualmap[qname] = num
  if 'fulldoc' in data:
    data['fulldoc'] = processDocumentation(data['fulldoc'])
  allEntities.append(data)
  return num

def grabDocs(path):
  for dirpath, dirs, files in os.walk(path):
    for f in files:
      if f[-5:] == '.json':
        appendJSONData(os.path.join(dirpath, f))

def appendJSONData(filename):
  with open(filename) as fd:
    data = json.load(fd)

  def recursiveAdd(jsondata):
    number = getNodeNumber(jsondata)
    for group in jsondata.get('members', []):
      group['members'] = [recursiveAdd(sub) for sub in group['members']]
    return number
  for node in data:
    recursiveAdd(node)
  print '\n'.join(str(foo) for foo in allEntities)


def buildDatabase(conn, tree):
  conn.executescript("""CREATE TABLE IF NOT EXISTS documentation (
    docid INTEGER NOT NULL PRIMARY KEY,
    docstart INTEGER NOT NULL,
    doclen INTEGER NOT NULL);""")
  
  needsComma = False
  with open(os.path.join(tree.target_folder, ".dxr-docs.json"), 'w') as outfd:
    for num in xrange(len(allEntities)):
      outfd.write(',\n' if needsComma else '[')
      needsComma = True
      start = outfd.tell()
      json.dump(allEntities[num], outfd)
      conn.execute("""INSERT INTO documentation (docid, docstart, doclen)
        VALUES (%d, %d, %d)""" % (num, start, outfd.tell() - start))
    outfd.write(']')

# Loaders for lazy database loading
loaders = {
  "file": FileEntity,
  "namespace": NamespaceEntity,
  "aggregate": AggregateEntity,
  "leaf": LeafEntity
}

class LazyDocumentationLoader(object):
  ''' A class which lets documentation be loaded lazily from the database. '''
  def __init__(self, conn, docfile):
    self.conn = conn
    self.docfile = open(docfile, 'r')

  def __del__(self):
    self.docfile.close()

  def getEntity(self, number):
    row = self.conn.execute(
        "SELECT * FROM documentation WHERE docid=%d" % number).fetchone()
    if row is None:
      return None
    self.docfile.seek(row['docstart'])
    data = json.loads(self.docfile.read(row['doclen']))
    return loaders[data["doctype"]](data, number, self)

def getDocumentedEntity(conn, instance_path, tree, num):
  lazyloader = LazyDocumentationLoader(conn,
    os.path.join(instance_path, 'trees', tree, '.dxr-docs.json'))
  return lazyloader.getEntity(num)
